# Ruby: Файлы в языке Ruby

Автор: А.Г. Верещагин, [vag8@mail.msiu.ru](mailto:vag8@mail.msiu.ru), 6 декабря 2011 года

Помимо оперативной памяти (ОЗУ) в компьютере есть еще один вид памяти - вторичная память, сохраняющая информацию даже после выключения компьютера. Как правило, вторичная память представлена жесткими дисками или твердотельными накопителями (флеш-память). Данные на вторичной памяти хранятся в виде файлов — поименованных последовательностей байт. Но файлом может быть не только статичная информация, зафиксированная во вторичной памяти. Через файлы может осуществляться взаимодействие между программами, и в этом случае их содержимое может располагаться в оперативной памяти или вообще определяться программно. Такие файлы иногда называют псевдофайлами. Методы работы с ними ничем не отличаются от методов работы с обычными файлами.

## Открытие и закрытие файлов

Для того, чтобы работать с файлом, его необходимо сначала *открыть*, поместив в переменную объект, представляющий данный файл. Дальнейшее взаимодействие с файлом можно осуществлять через этот объект. Файл можно открыть с помощью следующей конструкции:

```ruby
f = File.open(path, mode)
```

- `path` - это путь к файлу включая имя файла, он может быть абсолютный или относительный (относительно текущей директории программы). 
- `mode` - это режим работы с файлом. Он указывается в виде строки и может принимать следующие значения:

| Значение | Смысл | 
| -------- | ----- | 
| "r" | Только чтение, начиная с начала файла. Это значение по умолчанию, его можно не указывать. | 
| "r+" | Чтение и запись, начиная с начала файла. | 
| "w" | Только запись. Если файл существует, его содержимое будет перезаписано. Если файл не существует, он будет создан. | 
| "w+" | Аналогично "w", возможна операция чтения. | 
| "a" | Только запись. Если файл существует, он будет открыть на дописывание. Если файл не существует, он будет создан. | 
| "a+" | Аналогично "a", возможна операция чтения. |

При использовании того или иного режима надо быть уверенным в том, что программа имеет права на выполнение соответствующей операции с файлом. В противном случае будет сгенерирована ошибка.

По завершению работы с файлом его необходимо закрыть. Если файл не закрыть самостоятельно, он будет закрыт по завершению программы. Хорошим тоном считается всегда самостоятельно закрывать файл. Сделать это можно с помощью метода `close`:

```ruby
f.close
```

## Чтение и запись

Работа с файлами подобна работе со стандартными потоками ввода-вывода. Можно сказать и так: стандартные потоки ввода и вывода являются псевдофайлами, из которых происходит чтение и в которые осуществляется запись соответственно. Это означает, что работать с файлами можно с помощью уже знакомых методов: `gets`, `puts` и других.

### Методы ввода

Одним из основных методов чтения является метод `gets`. Данный метод может иметь один или два необязательных аргумента.

Один аргумент — это разделитель, т.е. символ или комбинация символов, до которого будет осуществляться чтение. Значение разделителя по умолчанию — это признак переноса строки. В разных ОС он различен. Интерпретатор Ruby инициализирует глобальную переменную `$/` «правильным» значением разделителя. Таким образом вызовы `gets` и `gets($/)` эквивалентны. В качестве разделителя можно указать пустую строку или `nil`. В первом случае чтение будет осуществляться до двух переносов строк (чтение «абзаца»). Во втором — будет прочитан весь файл.

Другой аргумент — максимальная длина прочитанного фрагмента. Будет прочитано не более указанного числа байт. Если методу `gets` передаются два аргумента, то данный аргумент идет вторым.

Метод `gets` возвращает прочитанную строку или `nil`, если файл был прочитан до конца.

С помощью метода `gets` из файла можно прочитать ровно один символ. Он так же возвращает `nil`, если файл уже был целиком прочитан.

Метод `readline` отличается от `gets` тем, что генерирует ошибку в случае достижения конца файла, а не возвращает `nil`.

Метод `readlines` читает все строки файла и возвращает их в виде массива. Как и методу `gets`, методу `readlines` можно указать, что считать разделителем строк и каким числом байт ограничиться, если нет необходимости читать весь файл.

### Методы вывода

Обычно данные выводятся с помощью метода `puts`. Метод `puts` принимает один или более объектов, которые он приводит к строковому виду и печатаются каждый на новой строке. Если передан массив, каждый элемент массива печатается на новой строке. Если вызывается без аргументов, просто печатается перевод строки.

В отличие от метода `puts`, метод `print` не вставляет между строковыми представлениями объектов перенос строки и не завершает им вывод. Если переопределить специальную переменную `$,`, то между печатаемыми объектами будет вставлен указанный разделитель. Пример:

```ruby
print 1, 2, 3 # => 123
$, = ", "
print 1, 2, 3 # => 1, 2, 3
```

Метод `printf` позволяет гибко описывать формат печатаемой строки. Описание этого метода довольно громоздко, поэтому оно не включено в данный урок. Почитать о printf на русском языке можно [здесь](https://ru.wikipedia.org/wiki/Printf) или [здесь](http://www.opennet.ru/man.shtml?topic=printf&category=3&russian=0).

Следует иметь ввиду, что при использовании операций вывода в файл данные не обязательно сразу будут записаны. Они могут оставаться в буфере, пока тот не будет заполнен. Так же запись в файл осуществляется в момент его закрытия. С помощью метода метода `flush` можно переместить данные из буфера в файл.

## Позиционирование в файле

Вспомните, как работаете с файлами в текстовых редакторах. Там можно установить каретку(курсор) в любое место и продолжить ввод или чтение оттуда. Данное действие осуществляется с помощью операции `seek`. Методу `seek` передается количество байт, задающее положение каретки. Вторым аргументом можно уточнить, откуда вести отсчет. По умолчанию отсчет ведется от начала файла. Доступны следующие значения второго аргумента:

- File::SEEK_CUR — отсчет от текущей позиции каретки. Первый аргумент может принимать отрицательные значения.
- File::SEEK_END — отсчет от конца файла. Для сдвига влево так же необходимо использовать отрицательные значения.
- File::SEEK_SET — отсчет от начала файла. Первый аргумент положительный.

С помощью метода `seek` можно образовать в файле «дыры». Эти дыры заполняются нулевыми символами (с кодом 0). Это непечатные символы, но иногда они могут выглядеть как пробелы.

Так же осуществлять позиционирование можно с помощью метода `pos=`. Например, можно написать так:

```ruby
f.pos = 13
```

Текущую позицию в файле можно узнать с помощью метода `pos`:

```ruby
f.pos # => 13
```
