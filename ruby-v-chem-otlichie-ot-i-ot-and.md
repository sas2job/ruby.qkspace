# Ruby: В чем отличие && от & и от and

Вкратце: `&&` используется для логических операций, `&` — для бинарных или побитовых операций, `and` — не используется 
(запрещен [style guide](https://github.com/arbox/ruby-style-guide/blob/master/README-ruRU.md#no-and-or-or)).

### Побитовые операции

Число в двоичной форме в Ruby можно записать как `0b1000...`. `5` в двоичной системе счисления это `0b101` (`14 + 02 + 1`), 3 как `0b011` (`04 + 12 + 1`), 1 как `0b001`.

Тогда побитовое "И" между 3 и 5 будет давать 1:
```ruby
0b101 & 0b011 # => 0b001

101 &
011
----
001
```

### Результат логических выражений

В Ruby можно писать вещи типа таких:

```ruby
x = condition && 5
```

В переменной `x` будет лежать 5, если `condition` верное (`true`), иначе в `x` будет лежать `false`. Если расставить все не обязательные скобки, то получится вот как:

```ruby
x = (condition && 5)
```

Т.е. `x` присваивается результат выражения `condition? && 5`. Что это за выражение? Для того, чтобы это понять, надо иметь в виду три вещи:

1. В Ruby все логические выражения выполняются ровно до тех пор, пока не будет заведомо известен результат. Так называемое "сокращённое вычисление логических выражений".

Если мы вычисляем `a && b && c && ...`, то ровно в тот момент, когда мы наткнёмся на первый `false` среди `a`, `b`, `c`, `...`, вычисление будет прекращено. В самом деле, если выражение содержит последовательность логических "И", то в тот момент, когда мы получили логическую "ЛОЖЬ", мы знаем, что всё выражение будет равно "ЛОЖЬ" – нет смысла дальше считать.

Если мы вычисляем `a || b || c || ...`, то ровно в тот момент, когда мы наткнёмся на первый `true`, вычисление будет прекращено. Если в "ИЛИ" выражении один из операндов (т.е. одно из участвующих значений) равно "ИСТИНА", то всё выражение заведомо равно "ИСТИНА", и нет смысла дальше вычислять.

2. В Ruby все управляющие выражения "возвращают" тот результат, который был вычислен последним. Например, `if` тоже возвращает значение и можно делать вот какие вещи:

```ruby
x =
if y > 5
"y is big"
else
"y is small"
end
```

Мы как бы вынесли присвоение "за скобки" (за логический оператор). Значением (результатом) `if-else` будет та строка, которая будет выполнена последней. Если `y > 5`, то это будет строка "y is big", а иначе строка "y is small". На выходе из `if` мы не отбрасываем этот результат, как обычно делаем, а перехватываем и запихиваем его в переменную.

Результатом выражения `a && b && c && ...` тоже будет то значение, которое будет вычислено последним (перед тем, как вычисление будет прервано в связи с тем, что результат всего выражения стал априори известен).

3. В Ruby для целей логических вычислений только `false` и `nil` считаются "ЛОЖНЫМИ". Всё остальное считается "ИСТИНЫМ". 

Например:

```ruby
# 0 это типа ИСТИНА
if 0
puts "0 это типа ИСТИНА"
else
puts "0 это типа ЛОЖЬ"
end

# [] это ИСТИНА
if []
puts "[] это ИСТИНА"
end

# nil это ЛОЖЬ
if nil
puts "nil это ИСТИНА"
else
puts "nil это ЛОЖЬ"
end

# Ну, с true и false понятно –
# первое ИСТИНА, второе ЛОЖЬ
```

### && vs and

Итак, вернёмся к нашему примеру:

```ruby
x = (condition && 5)
```

Если `condition` это ЛОЖЬ (например, для определённости, `false`):

- Вычисление выражения прервётся на этом самом `condition`, т.к. Ruby априори будет знать, что `condition && 5` заведомо ЛОЖЬ, даже не заглянет на "пятёрку".
- Последне вычисленное значение – `condition`, т.е. `false`
- Результатом выражения (`condition && 5`) будет последнее вычисленное выражение, т.е. `condition`, т.е. `false`
- В `x` будет присвоено `false`

Если `condition` это ИСТИНА (например `true`):

- Вычисление выражения продолжится после вычисления `condition`, дойдёт до конца, до 5, и в конце остановится.
- Последнее вычисленное значение – 5
- В `x` будет присвоено 5

Если же мы используем `and`, вместо `&&`:

```ruby
x = condition and 5
```

То Ruby расставит не обязательные скобки другим путём:

```ruby
(x = condition) and 5
```

(Потому что приоритет операции присвоения `=` выше, чем логической операции `and`. Однако приоритет логической операции `&&` выше, чем приоритет присвоения. Здесь никакой магии нет, надо просто понять, что это как `2+2*2` :-) )

Не трудно понять, что в `x` в любом случае окажется `true/false`, а `5` туда никогда не попадёт.

По современно стилю кодирования операции `and` и `or` признаны неудобными и не рекомендованы к использованию. В обучающих задачах по первой они используются для более простого понимания кода начинающими программистами (слова легче читать, чем специальные символы).

> Что все это значит? что за бинарные операции, что за логические, в чем разница и каким местом здесь потоки взялись?)

Бинарные операции – это просто вычисления "в столбик" с двоичным представлением числа, см. первый параграф.

Логические операции – это операции "И". "ИЛИ", "НЕ", которые выполняются над значениями типа "ИСТИНА" и "ЛОЖЬ". С дополнительными особенностями Ruby поверх этой логики – как обычные значения учитываются в логических выражениях (`false` и `nil` как ЛОЖЬ, остальное как ИСТИНА) и что будет возвращено как результат логического выражения (то значение, что было вычислено перед завершением вычисления всего выражения).

Ничего общего между побитовыми операциями и логическими выражениями нет – побитовые операции это разновидность (двоичных) арифметических операций, а логические выражения это способ управления потоком исполнения программы (при каких условиях какой код будет задействован).
